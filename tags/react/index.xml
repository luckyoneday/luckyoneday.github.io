<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>React on xuyou&#39;s blog</title>
    <link>https://luckyoneday.github.io/tags/react/</link>
    <description>Recent content in React on xuyou&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 16 Mar 2022 20:54:44 +0800</lastBuildDate><atom:link href="https://luckyoneday.github.io/tags/react/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>React 18 中的 Suspense SSR 架构</title>
      <link>https://luckyoneday.github.io/post/9-translate-lazy-suspense/</link>
      <pubDate>Wed, 16 Mar 2022 20:54:44 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/post/9-translate-lazy-suspense/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文标题: New Suspense SSR Architecture in React 18&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://github.com/reactwg/react-18/discussions/37&#34;&gt;https://github.com/reactwg/react-18/discussions/37&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>HashRouter vs BrowserRouter</title>
      <link>https://luckyoneday.github.io/daily/27-hashrouter-vs-browserrouter/</link>
      <pubDate>Thu, 11 Jun 2020 21:43:56 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/27-hashrouter-vs-browserrouter/</guid>
      <description>HashRouter 当渲染一个新路由时，使用哈希 routes 更新浏览器 URL (/#/about) 哈希不会被服务端处理，服务端只会匹配到 /，并且忽视后面的哈希值，所以会对所有路由请求返回 ind</description>
    </item>
    
    <item>
      <title>关于监听事件</title>
      <link>https://luckyoneday.github.io/daily/24-about-event/</link>
      <pubDate>Sun, 29 Mar 2020 14:53:32 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/24-about-event/</guid>
      <description>今天解决了一个画板独立的 bug，具体表现为当切换了画板的 tab 时，触发 wheel 事件会导致所有画布一起缩放。 后来查看 console 中的 eventListener 发现切换一个 tab 就会在 window 上添加</description>
    </item>
    
    <item>
      <title>React 怎么区分类组件和函数组件</title>
      <link>https://luckyoneday.github.io/post/1-translate-tell-class-from-function/</link>
      <pubDate>Sun, 08 Mar 2020 21:03:31 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/post/1-translate-tell-class-from-function/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;原文标题: How Does React Tell a Class from a Function?&lt;/p&gt;
&lt;p&gt;原文链接: &lt;a href=&#34;https://overreacted.io/how-does-react-tell-a-class-from-a-function/&#34;&gt;https://overreacted.io/how-does-react-tell-a-class-from-a-function/&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
    </item>
    
    <item>
      <title>这是一篇翻译</title>
      <link>https://luckyoneday.github.io/daily/21-translation-1/</link>
      <pubDate>Sat, 04 Jan 2020 11:33:06 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/21-translation-1/</guid>
      <description>是因为我在数组的 map 中使用了 hooks 触发了 eslint 检查，然后蓝教授扔了这篇文章给我。 太长不看版：有 hooks 的函数组件使用 JSX 或者React.createEleme</description>
    </item>
    
    <item>
      <title>Touch Event</title>
      <link>https://luckyoneday.github.io/daily/20-touch-event/</link>
      <pubDate>Sun, 22 Dec 2019 10:19:17 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/20-touch-event/</guid>
      <description>TouchEvent是一类描述手指在触摸屏面（触摸屏、触摸板）等状态变化的事件。属于一种UIEvent。该事件可以描述与屏幕的一个或多个触点</description>
    </item>
    
    <item>
      <title>鼠标为中心缩放的简单实现</title>
      <link>https://luckyoneday.github.io/daily/18-scale/</link>
      <pubDate>Fri, 20 Dec 2019 21:52:47 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/18-scale/</guid>
      <description>最终效果: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 // ... useEffect(() =&amp;gt; { const handleScale = (e) =&amp;gt; { // 这里用到了阻止默认</description>
    </item>
    
    <item>
      <title>拖拽的简单实现</title>
      <link>https://luckyoneday.github.io/daily/17-drag/</link>
      <pubDate>Thu, 19 Dec 2019 13:38:10 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/17-drag/</guid>
      <description>最终效果: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 useEffect(() =&amp;gt; { // 处理移动之类的 const handleMove = (e) =&amp;gt; { const left = nodePosRef.current.x; const top = nodePosRef.current.y; const</description>
    </item>
    
    <item>
      <title>随滚轮滚动的简单实现</title>
      <link>https://luckyoneday.github.io/daily/16-scroll/</link>
      <pubDate>Wed, 18 Dec 2019 15:03:24 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/16-scroll/</guid>
      <description>#root { width: 100%; height: 240px; border: 2px solid #f1f1f1; } .wrapper { width: 100%; height: 100%; } .inner { position: absolute; z-index: 10; width: 100px; height: 100px; transform-origin: 0 0; background: #1199ee; } 效果见蓝色方块。（移动端不支持） 这里就要用到之前提到过的wheelEve</description>
    </item>
    
    <item>
      <title>Wheel Event</title>
      <link>https://luckyoneday.github.io/daily/15-wheel-event/</link>
      <pubDate>Tue, 17 Dec 2019 17:21:52 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/15-wheel-event/</guid>
      <description>和scroll不同的是，scroll是监听页面或元素滚动，wheel是监听滚轮滚动。wheelEvent的默认操作是基于浏览器具体实现的，而</description>
    </item>
    
    <item>
      <title>debounce &#43; throttle</title>
      <link>https://luckyoneday.github.io/daily/14-debounce-throttle/</link>
      <pubDate>Mon, 16 Dec 2019 08:26:48 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/14-debounce-throttle/</guid>
      <description>真的是每次用的时候都需要查，一直分不清&amp;hellip;尴尬的一批 防抖 debounce 在事件触发 ms 之后再执行，在 ms 时间内随意触发事件，都会在这个时间内将之前</description>
    </item>
    
    <item>
      <title>关于 useLayoutEffect 和 useEffect 的区别</title>
      <link>https://luckyoneday.github.io/daily/5-react-hooks/</link>
      <pubDate>Mon, 02 Dec 2019 08:04:31 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/5-react-hooks/</guid>
      <description>首先看下官网对 useLayoutEffect 的解释。 作用其实和useEffect差不多，只是useLayoutEffect是在 DOM 变化后同步触发的（与componentD</description>
    </item>
    
    <item>
      <title>为什么 setState 是异步的</title>
      <link>https://luckyoneday.github.io/daily/3-async-setstate/</link>
      <pubDate>Sat, 30 Nov 2019 21:46:01 +0800</pubDate>
      
      <guid>https://luckyoneday.github.io/daily/3-async-setstate/</guid>
      <description>原 issue 地址: https://github.com/facebook/react/issues/11527#issuecomment-360199710 首先需要承认延迟 reconciliation 来批量更新对性能优化是有益的，从这点来看，setState同步更新在很多 case 下效率不高，批量更新是更好的选择。 比</description>
    </item>
    
  </channel>
</rss>
